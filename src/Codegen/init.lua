--[[
    Maui - Roblox Studio Plugin for Packing Modules as Executable Luau Scripts
    Licensed Under the LGPLv3 | Copyright (c) 2022-2023 Latte Softworks <latte.to>
    https://github.com/latte-soft/maui

    File: /src/Codegen/init.lua
    Desc: Handles the actual codegen assembly of a script, using instance props and code
    templates respectively
]]

local HttpService = game:GetService("HttpService")

local Root = script.Parent
local Packages = Root.Packages

local LuaEncode = require(Packages.LuaEncode)
local GetInstanceProperties = require(script.GetInstanceProperties)
local GetDefaultInstanceProperty = require(script.GetDefaultInstanceProperty)

local Version = Root.Version.Value

-- Get the LoadModule code (minified)
local LoadModuleCode = {
    Normal = script.LoadModuleCode["LoadModule.lua"].Value,
    Minified = script.LoadModuleCode["LoadModule.min.lua"].Value
}

-- Codegen format templates
local CodegenFormatTemplates = {
    Normal = [[
-- This script was automatically @generated by Maui, it is not intended for manual editing.

local ModuleRoot = ${SerializedModuleRoot}

${LoadModuleCode}]],
    Minified = [[
-- This script was automatically @generated by Maui, it is not intended for manual editing.
local ModuleRoot=${SerializedModuleRoot} ${LoadModuleCode}]]
}

-- VERY simple function to interpolate a certain string with a set of replacements, following
-- Luau's basic variable syntax rules
local function ReplaceString(inputString, replacements)
    return string.gsub(inputString, "${([A-Za-z_][A-Za-z0-9_]*)}", replacements)
end

-- Basic functions to get if we'll actually be able to read a(n) instance/selection, because
-- if it's parented to some locked-down service or whatevrr, we won't even be able to index basic
-- properties like even the name!
local function CanReadInstance(object, property)
    local CanRead = pcall(function()
        return object[property or "Name"]
    end)

    if CanRead then
        return true
    else
        return false
    end
end

-- Build script directly from a selection, passes through the console logging func
-- This returns the built script, IF it succeeded
local function BuildFromSelection(selection, options, log)
    local MinifyTable = options.Output.MinifyTable
    local UseMinifiedLoader = options.Output.UseMinifiedLoader

    -- Get instance properties from API dump (uses http)
    log("Retrieving all instance properties from API dump..", 2)
    local InstanceProperties, WasCached = GetInstanceProperties()

    assert(InstanceProperties, "Failed to get API dump, did you forget to allow HTTP requests on the plugin?")

    if WasCached then
        log("Using previously cached API dump", 2)
    end

    -- Now that we have the up-to-date API dump, we'll track how long it took to build for later
    local StartTime = os.clock()

    -- Initialize the output module root, then recursively walk through the real instance tree
    local ModuleRoot = {} do
        -- When we initially scrape the instance tree, we'll apply all references and their children here
        local ScrapedInstanceTree = {} -- [RealRef] = {<Children> ...}
        -- We need to keep track of ALL objects and create fake ref ids as we go
        local ReferenceIds = {} -- [[FakeRefId] = <Instance> RealRef

        -- Recursive function to actually walk through the real instance tree, and assign refs
        local function ScrapeInstanceChildren(instanceObject)
            if not CanReadInstance(instanceObject) then
                return {}
            end

            -- Add to ref ids
            table.insert(ReferenceIds, instanceObject)

            local ScrapedChildren = {} do
                for _, Child in instanceObject:GetChildren() do
                    ScrapedChildren[Child] = ScrapeInstanceChildren(Child)
                end
            end

            return ScrapedChildren
        end

        -- Initialize the scraped instance tree and assign all refs from root
        log("Scraping instance tree..", 2)
        for _, InstanceObject in selection do
           ScrapedInstanceTree[InstanceObject] = ScrapeInstanceChildren(InstanceObject)
        end

        -- Now, we'll recursively create the fake module root!
        local function CreateObjectTree(instanceObject, children)
            local ClassName = instanceObject.ClassName
            local InstanceIsAScript = instanceObject:IsA("LuaSourceContainer")

            local ObjectTree = {
                ClassName = ClassName,
                Reference = table.find(ReferenceIds, instanceObject)
            }

            if InstanceIsAScript then
                local ScriptSource = instanceObject.Source

                -- We need to make sure the script compiles correctly, EVEN IF the script is disabled.
                -- Since this serializes as a literal closure, we can't include syntax-incorrect code
                -- at ALL, or the codegen could be incorrect! We aren't RUNNING the func, though
                local LoadstringClosure = loadstring(ScriptSource)

                if LoadstringClosure then
                    -- We're using `FunctionsReturnRaw` on LuaEncode later, this will set the return
                    -- to the rew value, which is the script closure
                    ObjectTree.Closure = function()
                        local EndStatement = " end" do
                            local SplitSource = string.split(ScriptSource, "\n")
                            local LastLine = SplitSource[#SplitSource]
                            -- If the last line has a comment NOT followed by at least a "[" character, it means
                            -- that it's a full-line comment, and we need to call `end` on the next line
                            if LastLine and string.match(LastLine, "%-%-[^%[]") then
                                EndStatement = "\nend"
                            end
                        end

                        return "function() " .. ScriptSource .. EndStatement
                    end
                end
            end

            -- A class may not *ALWAYS* have an API dump entry, so we're just being safe here
            local ObjectProperties = InstanceProperties[ClassName]
            if ObjectProperties then
                for _, PropertyName in ObjectProperties do
                    -- Ignore BaseScript.Source (Because of script closure) and non-readable properties
                    if (InstanceIsAScript and PropertyName == "Source") or not CanReadInstance(instanceObject, PropertyName) then
                        continue
                    end

                    local PropertyValue = instanceObject[PropertyName]

                    local DefaultValue, PropertyValueIsNil = GetDefaultInstanceProperty(ClassName, PropertyName)
                    if not (DefaultValue == nil and not PropertyValueIsNil) and PropertyValue == DefaultValue then
                        continue
                    end

                    -- At this point, register the properties tbl in the object tree if it hasn't already been
                    if not ObjectTree["Properties"] then
                        ObjectTree.Properties = {}
                    end

                    -- Handle any special circumstances like refs, or else just add the property to the
                    -- table directly
                    if typeof(PropertyValue) == "Instance" then -- Then it's a ref
                        -- We'll actually create a dedicated tbl (if it doesn't exist) for ref props
                        if not ObjectTree["RefProperties"] then
                            ObjectTree.RefProperties = {}
                        end

                        local ReferenceId = table.find(ReferenceIds, instanceObject)
                        if ReferenceId then
                            ObjectTree.RefProperties[PropertyName] = ReferenceId
                        end
                    else
                        ObjectTree.Properties[PropertyName] = PropertyValue
                    end
                end
            end

            -- We meet again, attributes.. Luckily, LuaEncode takes care of this directly!
            local ObjectAttributes = instanceObject:GetAttributes()
            if next(ObjectAttributes) then
                ObjectTree.Attributes = ObjectAttributes
            end

            -- Recursively add children
            if next(children) then
                ObjectTree.Children = {}

                for Child, ChildrenOfChild in children do
                    table.insert(ObjectTree.Children, CreateObjectTree(Child, ChildrenOfChild))
                end
            end

            return ObjectTree
        end

        log("Creating encodable object tree..", 2)
        for Object, Children in ScrapedInstanceTree do
            table.insert(ModuleRoot, CreateObjectTree(Object, Children))
        end
    end

    log("Encoding object tree..", 2)

    -- Let's track when LuaEncode starts
    local LuaEncodeStartTime = os.clock()

    -- Serialize the module root, properties and all
    local SerializedModuleRoot = LuaEncode(ModuleRoot, {
        PrettyPrinting = if MinifyTable then false else true,
        IndentCount = if MinifyTable then 0 else 4,
        StackLimit = math.huge, -- I sure HOPE the user doesn't have a 500-object-deep instance tree, but we're not dealing with duplicates!
        FunctionsReturnRaw = true -- For Script.Source function closures
    })

    log("(LuaEncode) Serialized object tree in " .. string.format("%.3f", os.clock() - LuaEncodeStartTime) .. " (seconds)", 3)

    -- `MinifyTable` is the significant output, if that's minified we'll use the minified formatting for codegen directly
    local GeneratedScript = ReplaceString(if MinifyTable then CodegenFormatTemplates.Minified else CodegenFormatTemplates.Normal, {
        SerializedModuleRoot = SerializedModuleRoot,
        LoadModuleCode = ReplaceString(if UseMinifiedLoader then LoadModuleCode.Minified else LoadModuleCode.Normal, {
            Version = Version
        }),
    })

    -- Total end time for the whole build
    log("Finished codegen! Total build time: " .. string.format("%.3f", os.clock() - StartTime) .. " (seconds)", 3)

    return GeneratedScript
end

return {
    CanReadInstance = CanReadInstance,
    BuildFromSelection = BuildFromSelection
}
